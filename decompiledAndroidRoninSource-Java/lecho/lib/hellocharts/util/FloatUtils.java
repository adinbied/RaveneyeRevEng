package lecho.lib.hellocharts.util;

public class FloatUtils
{
  public static final int[] POW10 = { 1, 10, 100, 1000, 10000, 100000, 1000000 };
  
  public static boolean almostEqual(float paramFloat1, float paramFloat2, float paramFloat3, float paramFloat4)
  {
    float f = Math.abs(paramFloat1 - paramFloat2);
    if (f <= paramFloat3) {
      return true;
    }
    paramFloat1 = Math.abs(paramFloat1);
    paramFloat2 = Math.abs(paramFloat2);
    if (paramFloat1 <= paramFloat2) {
      paramFloat1 = paramFloat2;
    }
    return f <= paramFloat1 * paramFloat4;
  }
  
  public static void computeAutoGeneratedAxisValues(float paramFloat1, float paramFloat2, int paramInt, AxisAutoValues paramAxisAutoValues)
  {
    double d1 = paramFloat2 - paramFloat1;
    if ((paramInt != 0) && (d1 > 0.0D))
    {
      double d2 = roundToOneSignificantFigure(d1 / paramInt);
      double d3 = Math.pow(10.0D, (int)Math.log10(d2));
      d1 = d2;
      if ((int)(d2 / d3) > 5) {
        d1 = Math.floor(d3 * 10.0D);
      }
      d2 = Math.ceil(paramFloat1 / d1) * d1;
      double d4 = nextUp(Math.floor(paramFloat2 / d1) * d1);
      d3 = d2;
      paramInt = 0;
      while (d3 <= d4)
      {
        paramInt += 1;
        d3 += d1;
      }
      paramAxisAutoValues.valuesNumber = paramInt;
      if (paramAxisAutoValues.values.length < paramInt) {
        paramAxisAutoValues.values = new float[paramInt];
      }
      int i = 0;
      while (i < paramInt)
      {
        paramAxisAutoValues.values[i] = ((float)d2);
        d2 += d1;
        i += 1;
      }
      if (d1 < 1.0D)
      {
        paramAxisAutoValues.decimals = ((int)Math.ceil(-Math.log10(d1)));
        return;
      }
      paramAxisAutoValues.decimals = 0;
      return;
    }
    paramAxisAutoValues.values = new float[0];
    paramAxisAutoValues.valuesNumber = 0;
  }
  
  public static int formatFloat(char[] paramArrayOfChar, float paramFloat, int paramInt1, int paramInt2, char paramChar)
  {
    if (paramInt2 >= POW10.length)
    {
      paramArrayOfChar[(paramInt1 - 1)] = '.';
      return 1;
    }
    if (paramFloat == 0.0F)
    {
      paramArrayOfChar[(paramInt1 - 1)] = '0';
      return 1;
    }
    int k = 0;
    int j;
    if (paramFloat < 0.0F)
    {
      paramFloat = -paramFloat;
      j = 1;
    }
    else
    {
      j = 0;
    }
    int[] arrayOfInt = POW10;
    int i = paramInt2;
    if (paramInt2 > arrayOfInt.length) {
      i = arrayOfInt.length - 1;
    }
    long l = Math.round(paramFloat * POW10[i]);
    paramInt2 = paramInt1 - 1;
    paramInt1 = k;
    for (;;)
    {
      if ((l == 0L) && (paramInt1 >= i + 1))
      {
        i = paramInt1;
        k = paramInt2;
        if (paramArrayOfChar[(paramInt2 + 1)] == paramChar)
        {
          paramArrayOfChar[paramInt2] = '0';
          i = paramInt1 + 1;
          k = paramInt2 - 1;
        }
        paramInt1 = i;
        if (j != 0)
        {
          paramArrayOfChar[k] = '-';
          paramInt1 = i + 1;
        }
        return paramInt1;
      }
      int m = (int)(l % 10L);
      l /= 10L;
      k = paramInt2 - 1;
      paramArrayOfChar[paramInt2] = ((char)(m + 48));
      paramInt1 += 1;
      if (paramInt1 == i)
      {
        paramArrayOfChar[k] = paramChar;
        paramInt1 += 1;
        paramInt2 = k - 1;
      }
      else
      {
        paramInt2 = k;
      }
    }
  }
  
  public static double nextDown(double paramDouble)
  {
    double d = paramDouble;
    if (!Double.isNaN(paramDouble))
    {
      if (paramDouble == Double.NEGATIVE_INFINITY) {
        return paramDouble;
      }
      boolean bool = paramDouble < 0.0D;
      if (!bool) {
        return -1.401298464324817E-45D;
      }
      long l = Double.doubleToRawLongBits(paramDouble);
      int i;
      if (bool) {
        i = -1;
      } else {
        i = 1;
      }
      d = Double.longBitsToDouble(l + i);
    }
    return d;
  }
  
  public static float nextDownF(float paramFloat)
  {
    float f = paramFloat;
    if (!Float.isNaN(paramFloat))
    {
      if (paramFloat == Float.NEGATIVE_INFINITY) {
        return paramFloat;
      }
      boolean bool = paramFloat < 0.0F;
      if (!bool) {
        return -1.4E-45F;
      }
      int j = Float.floatToRawIntBits(paramFloat);
      int i;
      if (bool) {
        i = -1;
      } else {
        i = 1;
      }
      f = Float.intBitsToFloat(j + i);
    }
    return f;
  }
  
  public static double nextUp(double paramDouble)
  {
    double d = paramDouble;
    if (!Double.isNaN(paramDouble))
    {
      if (paramDouble == Double.POSITIVE_INFINITY) {
        return paramDouble;
      }
      paramDouble += 0.0D;
      long l = Double.doubleToRawLongBits(paramDouble);
      int i;
      if (paramDouble >= 0.0D) {
        i = 1;
      } else {
        i = -1;
      }
      d = Double.longBitsToDouble(l + i);
    }
    return d;
  }
  
  public static float nextUpF(float paramFloat)
  {
    float f = paramFloat;
    if (!Float.isNaN(paramFloat))
    {
      if (paramFloat == Float.POSITIVE_INFINITY) {
        return paramFloat;
      }
      paramFloat += 0.0F;
      int j = Float.floatToRawIntBits(paramFloat);
      int i;
      if (paramFloat >= 0.0F) {
        i = 1;
      } else {
        i = -1;
      }
      f = Float.intBitsToFloat(j + i);
    }
    return f;
  }
  
  public static float roundToOneSignificantFigure(double paramDouble)
  {
    double d;
    if (paramDouble < 0.0D) {
      d = -paramDouble;
    } else {
      d = paramDouble;
    }
    float f = (float)Math.pow(10.0D, 1 - (int)(float)Math.ceil((float)Math.log10(d)));
    return (float)Math.round(paramDouble * f) / f;
  }
}


/* Location:              C:\Users\adinb\Downloads\dex2jar-2.0\dex2jar-2.0\0x87b1d00c-dex2jar.jar!\lecho\lib\hellochart\\util\FloatUtils.class
 * Java compiler version: 6 (50.0)
 * JD-Core Version:       0.7.1
 */